	ปล. โน้ตนี้เป็นโน้ตที่กอล์ฟบันทึกย้ำเตือนตัวเองตอนฝึกทำข้อสอบค่ะ ปกติอาจารย์จะมีลิงค์รวบรวมข้อสอบปีก่อนๆให้ฝึกทำค่ะ
 (เทอมที่กอล์ฟสอบคือ fin76) ก่อนจะเริ่มฝึกทุกครั้ง กอล์ฟจะมาอ่านโน้ตย้ำเตือนตัวเองว่าห้ามพลาดจุดไหน ซึ่งไม่ได้วางแผนมาก่อนเลย
ว่าจะโชว์ลง github ดีมั้ย เพราะหนูก็ไม่ได้มั่นใจด้วยว่า สิ่งที่ตัวเองโน้ตไปมันถูกต้องแค่ไหน แล้วก็เขียนโน้ตเพื่อให้ตัวเองอ่านเท่านั้น 
แต่..ตัดสินใจแล้วว่าจะอัพลง github ด้วย อยากให้เห็นถึงความพยายาม ความตั้งใจในการศึกษาโค้ดมากกว่าค่ะ 
	ปลายภาคนี้จะให้เวลาในการทำข้อสอบค่อนข้างมาก โดยแบ่งเป็น 2 พาร์ท ทฤษฏีให้เวลา 2 ชั่วโมง 30 นาที  หลังจากนั้น
พักเที่ยง แล้วจึงสอบพาร์ทเขียนโค้ดให้เวลาอีก 2 ชั่วโมงครึ่ง อาจมีขยายเวลาให้เล็กน้อย ซึ่งการสอบปลายภาคจะครอบคลุมเนื้อหาทั้งหมด
ที่เรียนมา และเพิ่มความซับซ้อนมากกว่าเดิมหลายเท่า สิ่งที่เป็นอุปสรรคในการทำข้อสอบมากที่สุดก็คือ ความล้าในการใช้สมอง ซึ่งต้องคิด
ตลอดเป็นเวลาติดต่อกันหลายชั่วโมง อาจทำให้ใครหลายคนถอดใจได้เลย
13:39 11/11/2568

-------------------------------------
fin70
1. 
int operator()() { return a; } // int x= m(); คือตัว () เฉยๆ เหมือนเรียกใช้ฟังชั่นธรรมดา ไม่เกี่ยวอะไรกับการแปลง 
operator int() { return (*this)(); } // int x=m; คือตัวแปลงเป็น int โครตหลากหลาย
- f1().f2() ถ้า f1 คืนค่า A แต่ f2 เป็นของprotect ของคลาส B จะใช้ไม่ได้ A ไม่รู้จัก B
- ต่อไปนี้การแอสไซ obj=int อาจจะไม่ผิดแล้ว ต้องเช็คดีดีว่ามี operator int() เปล่า เรียกซ้อนกันได้
- ฟังก์ชั่นคืนค่าเป็น int แต่ข้างในคืนเป็น obj ก็ได้นะคะ เพราะมี ope ข้างบน
- แต่ระวังฟังก์ชั่นที่คืน obj แต่ข้างใน return เป็น int ต้องดูว่ามี A(int a) ไหม ถ้ามีคือรันได้ปกติ โอ้โห แต่ยัง cout ไม่ได้นะ เพราะคืนเป็น obj ต้องไปทำ ope << อีก
- int g7(int i) { return f1(i)(); } คือการเรียก f1() ส่งค่า A มาเรียก operator ()() ต่อ
- ต่อให้ฟังก์ชั่นรับพาราเป็น int ก็ยังสามารถยัดอ็อบเจ็กลงไปได้ค่ะ ถ้ามี ope int
- **กรี๊ดดดด ฟังก์ชั่นคืนค่าเป็น int แล้ว return อ็อบเจ็ก ยังสามารถแปลงเป็น int เพื่อแสดงผลหรือไปแอสไซค่าต่อได้ !!!!!!!!!!!!!!!แต่ถ้าเอาไปเรียกฟังกชั่นเชนต่อ ม่ายด้ายยยยยยย f1().plus(); X
- พาราที่รับคลาสแม่ เอาลูกไปใส่พาราแม่ได้ แต่จะเอาแม่ไปใส่พารารับเฉพาะลูกไม่ได้ แม่ไม่รู้จักลูก
- y.f4(y.f2()); ถ้า f2 ส่ง int กลับ แต่ f4 รับค่าเป็นคลาสต่างๆ ถ้าคลาสนั้นๆ ไม่มี class(int) จะพังทันที ต่อให้คลาสแม่มีคอนตรัค int แต่ลูกไม่มี ก็ไม่สามารถไปใช้ได้

-----------------------------------------

- e->getB()->hello(); แล้ว hello() เป็นของแม่คนเดียว ซึ่งข้างในก็เรียกฟังอีก void hello() { cout<<"hello "<<world()<<endl; ซึ่ง world มีทั้งแม่ทั้งลูก แต่เป็นเวอรชัว ก็เลยต้องไปเรียกใช้ของลูก
- การเรียกใช้ฟังก์ชั่น virtual ต้องดูว่าอ็อบเจ็กเป็นของคลาสไหน เช่น A *a= new D เวลาใช้ a->world() ต้องใช้ของ D ค่ะ
- ปลายภาคอจเน้นตรง virtual ต้องดูดีดีว่าฟังชั่นที่เรียกมี vertual ไหม ถ้าไม่มี ใช้ของแม่นะ 
- virtual ถ้าประกาศที่แม่แล้ว ลูก หลาน เหลน โหลน หากมีชื่อฟังชั่นเดียวกัน ก็จะเป็น virtual อัตโน
- อย่าโดนหลอก C สืบทอดจาก A อย่างเดียว ไม่ได้สืบทอดจาก B เวลาสร้างจะไม่ได้ไปเรียกคอนตรัคของ B นะ

-----------------------------------------

- setNum อย่าลืมเช็คด้วยว่าขนาดเท่าเดิมไหม
- default attribut ที่เป็นพ้อยเตอร์และ num กำหนด =0 ได้เลย เช่น num=0 Jelly=0

----------------------------
16:07 13/10/2568

- ฟังก์ชั่น int f2(){ return *this} ต้องใช้ operator int()
- ฟังก์ชั่น A f2() { return int} ต้องใช้ A(int)
- ทำนองเดียวกัน ถ้า B f3(){ return A a} ต้องใช้ B(A a)
- ระวังงง operator +(A a) ต้องดูว่าตัวที่มาใส่พารามิเตอร์ เป็นคลาส A ไหม ถ้าไม่ใช่ ดูว่าเป็นลูกหรือเปล่า ถ้าไม่ได้สืบทอดมา รันไม่ได้ค่ะ
- อย่าลืมดูเรื่องการสืบทอด ถ้า A มี operator int() แต่ B ไม่มีและไม่ได้สืบทอด B จะไม่มีสิทธิ์ในการแปลงเป็น int ใดๆเลย
- ฟังก์ชั่นที่อยู่ใน protected จะต้องใช้งานภายในคลาสเท่านั้น จะใช้ผ่านอ็อบเจ็กได้ก็ต่อเมื่อ อยู่ภายในคลาสเท่านั้น อยู่นอกคลาสคือผิดทั้งหมด ยกเว้นนนน Friend // อัพเดท การใช้งานฟังก์ชั่นโพรเทคผ่านคลาสอื่นๆด้วย>>อ็อบเจ็ก<< จะทำไม่ได้ทุกกรณี แม้แต่คลาสลูกเองก็ตาม
- เรื่องพ้อยเตอร์ เวลาเราประกาศเช่น *a จะเชนต่อเราต้องใช้ a-> แต่ถ้าเป็นอาเรย์ แล้วใส่เลขกำกับเช่น a[1] เราจะต้องใช้ . ย้ำว่าจะต้องนะ a[1].f1() ถ้าเป็นตัวธรรมดา a->f1() // อัพเดท ไม่เสมอไป ต้องดูว่าพ้อยเตอร์ตัวนั้นจองพื้นที่ไหม ถ้าจอง new สามารถใช้ . ได้เลย แต่ถ้าไม่จอง แล้วก่อนหน้านี้ไปแอสไซให้เท่ากับอ็อบเจก ยังคงต้องใช้ ->
- a = b.g3(d[0]+d[1]); ตอนแรกคิดว่าผิด เพราะ d ทั้ง2 เป็นคลาส C ซึ่งไม่มีมี ope + แต่เพิ่งรู้ว่ามันสามารถแปลงไปแปลงมาได้คือ คลาส C มี ope int สามารถแปลงเป็นเลขได้ก่อน แล้วฟังก์ชั่น g3(A a) รับคลาส A ซึ่งคลาส A มี A(int) จึงสามารถแปลงเลขที่บวกกันเสร็จแล้วเป็นอ็อบเจ็กคลาส A ส่งต่ออากูเม้นไปได้
- โพริมาฟิซึม แม่สามารถชี้ไปลูกได้ตลอด B *h = new C[2]; แต่ถ้า C ไม่ได้สืบทอดจาก B ชี้แบบนี้จะผิดผีทันที
- ต่อ ถ้าเรียกฟังก์ชั่น ในคลาส C จะผิดทันที เพราะตัวชี้มีสถานะเป็น B หรือ B *h แต่ถ้าฟังก์ชั่นในคลาสแม่มี virtual แล้วไปเรียกฟังก์ชั่นคลาสลูกที่ชื่อเดียวกัน ก็ยังสามารถเรียกได้

**********************************************************
fin74

จับผิด
- อย่าลืมสิ พารานอกคลาสเรียก แอททริบิ้วโต้งๆไม่ได้ 
- การแปลงเป็น int ด้วย ope จะทำได้ทั้งข้างหน้าและข้างหลัง
- อจ เริ่มมีการหลอกฟังก์ชั่นชื่อเหมือนๆกัน ต้องดูให้ดีดีว่า เวลาเรียกใช้ใส่อะไรลงไป เพราะ ชื่อ int หรืออ็อบเจ็กเหมือนกันมาก
- นอกคลาส ถ้าลูกไปเข้าถึงแอทบิ้วคลาสแม่ ต่อให้ลูกเป็นเฟรนกับคลาสนั้นแล้ว แต่ถ้าแม่ไม่ได้เป็นเฟรนด้วย จะเข้าถึงแอทบิ้วโดยตรงไม่ได้ เช่น cout<<c.g(a.f())+b.a<<endl; b.a ไม่ได้ แม่ไม่ได้เป็นเฟรน
- ลืมไงล่ะ ฟังก์ชั่นโกลบอลนอกคลาสต่างๆ ไม่สามารถเรียกด้วยอ็อบเจ็กได้ ต้องเรียกเพียวเลยเช่น ใน main 
hello() ไปเลย
-  a=c.h(b).g2(b)+c; MVP มากกกกก บรรทัดนี้รันได้ปกติ เพราะ A มี A(int) 
   c=c.h(b).g2(b)+c; แต่อันนี้ไม่ได้ ต่อให้อันหลัง g2 ส่งค่า int ไป + c สามารถแปลง c ไปเป็น int ได้ด้วยคุณสมบัติสืบทอดจาก A ก็จะได้ค่า int จาก a มา แต่สำหรับบรรทัดนี้ตัวรับค่าคือเจาะจงเลยว่าเป็น c ดังนั้น จะใช้ A(int) ไม่ได้อีกแล้ว ถ้าในคลาส C ไม่มี C(int) เท่ากับผิด 
- int h2(B b) { return g4(b).g1().f(); }
  A h2(C *c) { return this->c+*c; }
  int h2(A &x) { return c=g(x).g1()/(*this); }
  จาก overloading ทั้ง 3 แบบ เมื่อเราเรียกใช้และใส่ค่า c.h2(c2) ลงไป ระบบจะไปเลือกว่าจะใช้อันไหน ซึ่งอันกลางใช้ไม่ได้ละ 1 เพราะรับค่าเป็น * ต้องใส่ & ด้วย จึงไปเลือกที่เหลือที่เป็นคลาสแม่แทน แต่จะเห็นว่าต่อให้เลือกใช้อันใดอันหนึ่งก็ผิดอยู่ดี เพราะคืนค่าเป็น int จะเชนทำฟังก์ชั่นต่อไม่ได้ k=c.h2(c2).f();
---------------------
- ฟังก์ชั่นที่คืนค่าเป็นพ้อยเตอร์และรีเทิน this จะไม่ก๊อบ B* f1(){return this}
- B():A(){} แบบนี้ไม่ก๊อป A เพิ่มนะคะ เท่าเดิมเลย
- B():A(),C(){} สร้างเรียงตามนี้ก็จริง แต่ถ้าตอนประกาศสืบทอด เป็น class B : public C,public A ก็ต้องไปเรียกของ C ก่อนค่ะ
- การเรียก constructor ที่สืบทอดกันหลายๆคลาส คลาสแม่จะได้ค่าของคลาสล่าสุดที่สร้างระบุไว้เช่น 
B():A(6),C(){} ต่อให้มีการเรียกก่อนหน้านี้ ถ้าสร้างจาก B b ก็จะยึดการกำหนดค่าที่ B // อัพเดทเพิ่มเติม fin 74 re
- virtual ถ้าฟังก์ชั่นคลาสลูกมีชื่อเหมือนกัน แต่พาราไม่เหมือนกัน ระบบก็จะยึดจากฟังชั่นของแม่
- ตอนลบ จะเรียก destructor แบบย้อนกลับ ที่ย้อนกลับจริงๆ อย่ามโนเองว่าต้องแบบนั้นแบบนี้ เรียงย้อนกลับจากตอนสร้างเลยค่ะ
- จะกรี้ด operator int(){get()} แล้วในคลาสแม่ get เป็น virtual เวลาเราแปลงเลขจากคลาสลูกคลาสไหน เวลาแปลงจะได้ค่าจาก get คลาสนั้นค่ะ 
- ดูดีดีอันไหนอาเรย์[] อันไหน construct ()
- ถ้าฟังก์ชั่นไหน ไม่ได้ประกาศ virtual เวลาพ้อยเตอร์แม่เรียกใช้ฟังก์ชั่น จะใช้ของแม่ เช่น A *a=B b
a->f4() (ซึ่งจริงๆ B ก็มี f4()) จะใช้ของแม่
- ตอนจบอย่าลืมไล่กาทิ้งด้วยตัวไหนที่ destructor ไปแล้ว เดี๋ยวงง
-------------------------------
- อย่าลืมที่ copy จะเข้าคอนตรัค A(A a) ทุกครั้ง ถ้ามี cout ห้ามพลาด
- ทุกๆการดำเนินการใดๆบน return จะไม่อัพเดทค่านะคะ เช่น x=2 ถ้า return x+100 ได้ 102 แต่ x ยังเท่ากับ 2 อยู่
- ระวังข้อที่มี operator เยอะๆ โครตงง ภายใน ope ยังมีต่อได้เยอะมาก โดยเฉพาะ = 


**********************************************************
fin75

จับผิด
- ลืมเรื่อง คลาสลูกเข้าถึงแอดบิ้วแม่ตรงๆ
- ฟังก์ชั่นที่รับพาราเป็น & เช่น f1(A &a) จะไม่สามารถรับค่าที่เป็น temp หรือตัวก็อบปี้ได้
- ท่องเลย ทุกคลาสไม่สามารถแปลงได้เหมือนกันหมด  c=7 แต่คลาส C ไม่มี C(int) ก็ผิดดดดด
- แม่ใช้ลูกไม่ได้ ฮืออออออออออออออออ
- ระวังเรื่องการ endl บางครั้งเชนหลายครั้งอาจจะเผลอ
- cout << "test " << io.f4()->getB() << endl; ผลรันจะได้ตัวที่อยู่ในฟังก์ชั่นก่อนนะ ข้างใน f4() จะมี cout << "-B-" ค่อยกลับมาทำ cout หลัก จะได้  -B- test 114
- ปกติแล้วโพลิมอฟิซึม จะแสดงคลาสแม่ แต่อจอาจหลอกได้ โดยการตั้ง virtual ไว้ที่คลาสลูก เวลาคลาสหลานเรียกฟังก์ชั่นดังกล่าวจะทำให้งงว่าทำไมไม่เรียกคลาสแม่ ถ้าแม่เรียกเองจะใช้ที่คลาสแม่ แต่ถ้าตั้งแต่ลูกลงมาเรียกใช้งาน จะผลักไปตัวคลาสสุดท้าย
--------------------------
OP /2
- เวลาบรรทัดไหนมีเชนฟังก์ชั่นเยอะๆ พวก copy ต่างๆจะยังไม่ตาย ถึงแม้จะจบฟังก์ชั่นนั้นๆแล้ว รวมถึง copy ที่มาจากพารา ก็ยังไม่ตาย จนกว่าจะจบบรรทัดนั้น ถึงจะตายเรียง // recheck
* ยกเว้นตอนสร้าง A x = f(); ตัวก็อบจะไม่ถุกทำลาย
- จากข้างบน A x = f(); จะไม่เรียกดีฟอลคอนด้วย
- อ็อบเจ็กซ้อนอ็อบเจก จะเริ่มสร้างจากข้างในก่อนมาสร้างตัวหลัก
------------------------------------------------
fin 73

จับผิด
- ระวังเรื่องการแปลงค่า รอบนี้มีแปลง string แต่ ฟังก์ชั่นรับ int ก็ไม่แปลงให้นะคะ
- เรื่อง protected อย่าเอ๋อค่ะ ถ้าอ็อบเจ็กจะใช้งานฟังจากโพรเทค ต้องดูว่าอ็อบเจ็กนั้นอยู่ในคลาสไหน ถ้าอยู่คลาสตัวเอง แต่ให้ไปใช้โพรเทคคลาสแม่คลาสยาย ก็ย่อมได้ค่ะ
- การcopy คอน ต่อให้เราไม่ประกาศ B(B a) ระบบก็จะสร้างให้อัตโนมัติ
- อจออกเรื่อง . -> ด้วย
----------------
fin 74 re

จับผิด
- การมี copy เกิดขึ้นที่จุดใดๆ ระบบจะตรวจสอบหา construc copy ที่เราเขียนเองก่อนว่ามีไหม ถ้าไม่มีระบบจะใช้ copy ของระบบเอง ซึ่งจะไม่มี cout แต่ถ้าตัวข้างในอ็อบเจก มีออบเจกย่อยอีก ถ้ามีเขียนคอนตรัค copy ไว้ ก็จะไปใช้นะ
- แม่เป็นเฟรนกับฟังก์ชั่นนอก ลูกไม่รู้จักด้วย
- กรณีที่การเรียกฟังก์ชั่นเป็นไปได้หลายรูปแบบ โอเวอไรดิ้ง จะมี 3 ขั้นตอน 1 รวบรวมรายชื่อ 2. ดูว่าอันไหนแมชที่สุด (กรณีที่ไม่มีอันไหนแมชเลย error หลุด) แต่ถ้ามีอันที่แมชแล้ว 3. ข้างในรันต่อไม่ได้ error จะไม่กลับมาหาอันที่แมชอันอื่นต่อ เช่น มี f1(A a),f2(int) จะเอา a ไปใส่ ซึ่งจริงๆ สามารถแปลงเป็น int ไปใส่ใน f2 ได้ แต่ระบบโง่ค่ะ เห็นตัวที่แมชสุดคือ f1 ไปเลย แต่เป็น protect ก็ error ผิดไปตามระเบียบ
---------------------------------








