	ปล. โน้ตนี้เป็นโน้ตที่กอล์ฟบันทึกย้ำเตือนตัวเองตอนฝึกทำข้อสอบค่ะ ปกติอาจารย์จะมีลิงค์รวบรวมข้อสอบปีก่อนๆให้ฝึกทำค่ะ 
(เทอมที่กอล์ฟสอบคือ mid30) ก่อนจะเริ่มฝึกทุกครั้ง กอล์ฟจะมาอ่านโน้ตย้ำเตือนตัวเองว่าห้ามพลาดจุดไหน ซึ่งไม่ได้วางแผนมาก่อนเลย
ว่าจะโชว์ลง github ดีมั้ย เพราะหนูก็ไม่ได้มั่นใจด้วยว่า สิ่งที่ตัวเองโน้ตไปมันถูกต้องแค่ไหน แล้วก็เขียนโน้ตเพื่อให้ตัวเองอ่านเท่านั้น 
แต่..ตัดสินใจแล้วว่าจะอัพลง github ด้วย อยากให้เห็นถึงความพยายาม ความตั้งใจในการศึกษาโค้ดมากกว่าค่ะ 
	สำหรับกลางภาคจะมีการจับเวลา เพราะสอบครึ่งแรก จะครอบคลุมเนื้อหาดังนี้ 1. class, object 2. constructor&destructor 3. dynamic array 4. friend 5. inheritance สิ่งที่เห็นเป็นตัวเลข
บน HEAD แต่ละส่วนคือเวลาที่กอล์ฟใช้ทำ (ฝึกจับเวลา) ส่วน * หน้าข้อคือข้อที่ทำถูก 
10:21 11/11/2568

---------------------------------------------
mid29

obj1.f1(obj1).f2(obj1); บนฟังชั่น  ค่าต้นเปลี่ยนด้วย

A f1(A k){
        a+=1000;
        return *this;
    }                               destruc 5
A f2(A i){
        cout << a << endl;
        return *this;
    }
----------------------
A& f1(A k){
        a+=1000;
        return *this;
    }                               destruc 3
A& f2(A i){
        cout << a << endl;
        return *this;
    }
---------------------
A f1(){
        a+=1000;
        return *this;
    }                               destruc 3
A f2(){
        cout << a << endl;
        return *this;
    }
------------------------
A& f1(){
        a+=1000;
        return *this;
    }                               destruc 1 ตัวมันเอง
A& f2(){
        cout << a << endl;
        return *this;
    }

----------------------------------------------------
2.
1 a=3    สร้างobj พ้อยเตอร์แล้ว จะเรียกคอนตักไหม // ไม่สร้างส
2 B b=7 a=5
3 a=3
4 6
5 a=3*    B():A(5) ดูดีดีว่า A(5) ไม่ใช่ default con A(int a) ไม่เรียก show 
6 B b=7 a=5
7 a=5*  
8 BB b=5 a=5
9   7               
10 11
11 b=8 a=3
12 a=6
13 10    *this คืออัพเดทที่ตัวข้างนอกด้วยใช่ไหม 
14 a=3
15 B b=7 a=5
16 ~B b=7 a=5
17 ~A a=5
18 ----oop-----
19 
20 

---------------------------------------------------
1. type มีกี่ประเภทดูให้ดีดี แต่ละคลาสมีจำนวนไม่เท่ากัน ดังนั้นเวลาจะใช้ if a<0 a<1 สำคัญมาก 
4. ฟังชั่นส่วนลด ทำแต่ sum ชอบลืมหักส่วนลด
5. ลืม count-- ในดีตรัค
***6. ห้ามเปลี่ยนค่าเองงงง จะใช้ (int a, int b, int c) เรียง abc แบบที่เคยทำไม่ได้ ต้องดูโจทย์ว่าให้เป็นตัวอะไร 
***7. ห้ามลืมคืนค่าพื้นที่
8. เวลาgetค่าอ็อบเจ็ก ควรใส่ & เพราะเวลาจะเรียกซ้อนเรียกตัวแปรต่างๆ จะทำให้ค่าต้นเปลี่ยนเช่น
 getPork(0).setPrice(50);
9. คลาสที่มี * ** หรืออาเรย์ ต้อง setNum ก่อนกำหนดค่านะจ๊ะ
10. การกำหนดค่าอาเรที่ชี้ไปอาเร เช่น ** ชี้ไป * จะใช้ a=b ตรงๆไม่ได้ค่ะ ต้อง *a=b หรือ a=&b
11. หากมีตัวที่ต้องเข้าถึงตัวแปรในคลาสที่มีคืนพื้นที่ ควรทำเป็นลำดับสุดท้าย เช่น show ก่อน ค่อย delete
12. อย่าลืมใส่ return ฟังชั่นที่เป็น data type

------------------------------------------------------------
MID28   6.53-7.36 (43 min)

*1. A f2(A a) { return a.plus(); } // a.plus();
2. B* f4(int y) // this->b = y;
3. A f6() { return A(b++); // return A(b++) เซ็ตค่า a แต่คลาส b ไม่มี a
*4. C g2(A a) // b.f1(a); ใช้ protect นอกคลาสไม่ได้
5. return add(A(plus().get()+i));
6. i=x.add(c.g1().f3()).a; i เป็น int ไป = อ็อบเจ็ก
*7. return c.g4().b.a; // .b.a เข้าถึง a ไม่ได้ปะ
*8. a = c.g3(b.f4(i)->f5(b).f6());  g3 รับ int แต่ข้างในส่งอ็อบเจ็กกลับ

----------------------------------------------------------
15.54-

B::aa   --->   A*[]   --->   A object   --->   int

เวลา new จะจองพื้นที่ไหม จะเรียก construc ไหม // จองด้วยเรียกด้วย ถ้าเป็น *new ไม่สร้างไม่เรียก 
a1.plusTwo().plusTwo().show(); อันนี้ยังไง *this จะอัพเดทตัว ori ด้วยไหม // อัพด้วย
เวลาสร้างอ็อบ อย่าลืมการสืบทอด เรียกคอนตรัคให้ครบ

1 Hello A
2 AA a = 7
3 i like it
4 Hello A
5 B b = 2
6 a = 5

~A a = 5       return *this ไม่ใช่ ref เสมอไป ต้องดูชื่อฟังชั่นว่าเป็นแบบไหนถ้า 
A f2() การันตีได้เลยว่าเกิดการ copy ขึ้นแน่นอน แต่ถ้า A* f2() หรือ A& f2() จะไม่ก๊อบ

การใช้ this จะหมายถึง พ้อยเตอร์นะคะ (ที่ชี้ไปตัวอ็อบเจกปัจจุบัน)
การใช้ this คู่กับฟังก์ชั่น เช่น
A* plusTwoPtr() {
    a += 2;
    return this; // ไม่มี copy เพราะแค่ส่ง pointer
}
จะเห็นว่า A* ส่งกลับค่าด้วยพ้อยเตอร์ ซึ่ง this มีสถานะเป็น? ย้อนไปอ่าน

A& plusTwoPtr() {
    a += 2;
    return *this; // ไม่มี copy เพราะแค่ส่ง pointer
}
อะไรไม่รู้แต่ถ้าจะใช้ A& ต้องใช้ คู่กับ *this เท่านั้นนน

7 ---wow---
8 Hello A        
9 b = 1
10 Hello A
11 b = 7
12 Hello A
13 B b = 2
14 a = 5
15 a = 5 **ต้องดูว่าค่าที่ส่งไป + เป็นตัวก๊อบไหม จะอัพเดทค่าหรือเปล่า
16 ---hey---
17 Hello A
18 B b = 2
19 Hello A
20 B b = 2
21 Hello A
22 B b = 2
23 ~B b = 7
24 ~A a = 5
25 Hello A
26 B b = 2 
27 1
28 7
29 2
30 ~B b = 1
31 ~A a = 4
32 ~B b = 2
33 ~A a = 10
34 ~B b = 4
35 ~A a = 6
36 ---finish---
37 ~B b = 1
38 ~A a = 4

~A a = 4 มาจากไหน งง

39 ~B b = 7
40 ~A a = 5
41 ~B b = 2
42 ~A a = 6
43 ~B b = 2
44 ~A a = 5
45 ~A a = 7
46 ~A a = 5
47 
48 
49 
50 

-----------------------------------------
1. พวกฟังก์ชั่นที่ set ค่า num เพื่อกำหนดขนาดอาเรย์ อย่าลืมกำหนดค่าให้ meatnum vegnum ด้วย
ไม่ใช่ new อย่างเดียว
2. พวกคำสั่ง getObject ต้องใส่ & ด้วยเพื่ออัพเดทค่า
3. ในลูป จะแสดงค่าโดยพิมพ์คำสั่งอย่างเดียวไม่ได้ เช่น getPrice() ต้อง cout ด้วย เหมือนตอนพิมธรรมดา ยกเว้น show()
4. ศึกษาการเพิ่มข้อมูลลงอาเรย์พ้อยเตอร์
5. ในลูป i หรือ j ดูให้ดีดี 

*************************************************************************************************************************
Mid27     15.11-15.48 (37 นาที)

* คือฟังก์ชั่นที่ผิด
f1-4 222333// f1 f4
g1-6 35665// g1* g2 g3
h1-4 22 // h1 h3* h4
k1-6 125332544// k1 k6

1. b=f2(a).f3();
2. d = d.k5(c.h2(b.g5()).f3()); // ตัวสุดท้ายส่ง a
3*. d.k3(c.f2(a)); // k3 รับค่า int แต่ใส่ f2 จะส่งอ็อบเจ็กไป
4*. d.c = c; return d.c.b; // คลาส c ไม่ได้เป็นเฟรน
5.

A a(i); return f4(a, A(j)); คืออะไร ส่งอากิวเม้นเป็น คอนตรัค // มันคือการสร้างอ็อบเจ็กชั่วคราว คล้ายๆการ copy มันอยู่จนถึงจบฟังก์ชั่น **ใช้ไม่ได้กับ & เช่น f1(A &a) จะส่ง f1(A(5))ไม่ได้ค่ะ
อันนี้จะเรียกทั้ง con และ de เลยนะ

- เริ่มต้น ควรไล่ดูทุกฟังก์ชั่นก่อน ค่อยไป main 
- ไล่ดูทุกฟังก์ชั่น อันไหนมีเรียก protect
- ไล่ดูว่ามีการใช้งานตัวแปรตรงๆหรือเปล่า มาจากนอกคลาสหรือเปล่า 
- การสืบทอด ลูกไม่สามารถเข้าถึงสมาชิกของแม่ได้ a.b ไม่ได้
- d.c = c ถูกต้องแล้วคืออ็อบเจ็กไปเท่ากับอ็อบเจ็ก เพราะ d.c คือ อ็อบเจ็ก c ที่อยู่ในคลาส d อีกที
Class D{C c; } แล้วเป็น friend กับฟังก์ชั่นนี้เลยใช้ d.c ได้ ซึ่งปกติจะผิดดด
- cout << obj1 << endl; ไม่ได้นะคะ
- ดูวงเล็บให้ดีดีว่าใครคือคนคุมจริงๆ d = d.k5(c.h2(b.g5()).f3()); จะเห็นว่าคนคุมคือ k5 ไม่ใช่ f3 ดูวงเล็บดีดี

------------------------------------------------------
17.32-17.46  17.50-18.20   14+30= 44

- สร้างอ็อบเจ็บพร้อมใส่พาราลงไป คลาสแม่จะเรียกใช้คอนตรัคด้วยไหม เช่น  B เป็นลูก A แล้วเรียก B ob1(4)
จะไปเรียก A(4) หรือ A() //เรียกแค่ A()
- setB(k).show(); เรียกโชว์ของคลาสไหน // คลาสที่ setB รีเทิน
- setA(k+1).show(); k ตัวจริง + ด้วยไหม // ไม่+
- c2.setC(6).setB(5).setA(8).show(); โชว์ของใคร // รีเทินของ setA

- ฟัง์ชั่นแวรู A f1() {return *this} จะแอบมีการ copy อ็อบเจ็กส่งกลับไป แต่จะไม่เรียก default con จะไปทำฟังชั่นที่เรียกเรื่อยๆ จนจบ ; และก็ destructor
- อจ หลอก destruct แต่ละคลาสเขียนไม่เหมือนกัน

---------------------------------------------------------
- แอททริบิ้วที่เป็นคลาสอยู่อีกคลาสนึง ให้ระวังเรื่อง set get ให้ดี ใส่ให้ถูกที่
- ตัวแปรที่เป็น ** เวลาเรียกคำสั่งต้องใช้ -> หรือ getตัวนั้น.คำสั่ง
- เวลาตั้งชื่อแยก เช่น showRing หรือ setSoupType ชอบลืมตอนเรียกใช้ใน
main 
- ฟังก์ชั่นที่รับค่าเป็นพ้อยเตอร์เช่น f1(int a, Gem *b) เวลาใส่อากิวเม้น ต้องมี & ด้วย เช่น 
f1(1,&obj1);
- for loop เราต้องประกาศ int i=0 ทุกครั้ง ตราบที่เรายังไม่ได้ประกาศนอก for

***********************************************************
***********************************************************
mid26

15.17-15.38

1.  int f1() { a+=a; } // ไม่รีเทิน
2. int g1(A x) { b=x.f4(); } // ไม่รีเทิน
3*. k = c->h3(*c).g1(a); // protect
4. c->h6() = b.g3(c->g3(b)).f4();
5. C() { c=f1(); }

- ระวังโดนหลอก this->a=b แต่ a อยู่คลาสแม่ ใช้ไม่ได้จ้า
- แยกระหว่างอ็อบเจ็กกับตัวแปรให้ออก void g2(A a) { this->a=a; } อันนี้ผิด 2 จุดเลย ตามข้อ 1 และ ไปเท่ากับ a ซึ่งเป็นอ็อบเจ็กจากพารา ไม่ใช่ตัวแปร ต่อให้เป็นตัวแปรก็เท่ากับไม่ได้ อยู่ในคลาสแม่
- โดนหลอกอีกแล้ว ถึงแม้เรียกฟังชั่น protec ภายในคลาสเดียวกันก็จริง แต่ดูตัวเรียกด้วย เช่น h1 อยู่คลาส C
C h4(B b, int i) { return b.h1(i); } ตัวเรียก h1 คือ b มาจากคลาส B ค่ะ
- ระวังพวก chain เยอะๆ ฟังชั่นก่อนรีเทินอ็อบเจ็กคลาสไหน ไปเรียกฟังคลาสไหนต่อ cout<<c->g5(d.f2(a)).g3(b).f4()<<endl; g5 ส่ง A กลับมา แต่ g3 อยู่ใน B แม่ใช้ของลูกไม่ได้

---------------------------------------------------
17.20

- สร้างอาเรย์ จะเรียก default con ทุกตัว
- ถ้า B สืบทอด A 
b.set(bb[0].add(a).get()); แล้ว add คืนค่า A แล้วไปเรียก get จะใช้ get ของใคร // get ของ รีเทิน add
- cout<<b<<" "<<A::get()<<endl; คือค่าของ b ไม่ใช่พิมพ์ "b"
- A add(A &x) { return A(a+x.a); } ก็อบปี้ตรง A(a+x.a) ด้วย
-------------------------------------------------------

- อย่าลืมม ไม่ show บน cout <<
- คลาสที่มี แอททริบิ้วเป็นอ็อบเจ็ก อย่าลืมตั้ง setSize ให้เขาด้วย
- ใน setNum อย่าลืมกำหนดค่าให้ num ด้วย num=a
- อย่าลืม ~destructor คืนพื้นที่ delete[]

**************************************************************
**************************************************************
Mid25

16.47-17.12 (25)

1*. int g1(int i) { return b.f1(i); } // เรียก pro
2*. int f7(int i) { return b.f4(i); } // เรียก pro
3*. cout<<b.set(c.g3(a)).f2(a)<<endl; // ส่งอ็อบเจ็กมาที่ cout
4. friend void g5(A a); // (A a) ฟังชั่นจริงเป็น (A k) ไม่ผิดจ้า
5*. b.set(k.a); // k.a

b1=b2=2; ได้หรอ // ได้
B g2(A a) { return b.set(a.get()); }  รีเทิน A ในแต่ฟังเป็น B แต่ใน main มีคนเรียกใช้ แสดงไม่น่าผิด // ดูผิดเอง ไปดู set ของ A ทั้งๆที่ set มันมีทั้ง A และ B แต่อันนี้ b เป็นคนเรียก ก็จะรีเทิรนเป็น B 
- c.b.b2=k.get(); ถึงแม้ c เป็น friend แต่ไปเรียกถึง b2 ซึ่ง B ไม่ได้ประกาศเฟรน จะทำแบบนี้ไม่ได้

---------------------------------------------
18.26-18.56 (30 )

- get มันชอบแฝงอยู่บรรทัดที่มีฟังเยอะๆ จะแอบรีเทินอ็อบ แล้วก็ต้อง copy 

---------------------------------------------
15.59-16.46 (47)
18.02-18.17 (15)

- ก่อนเริ่มต้องไล่ดูก่อนว่าตัวแปรนับอ็อบอยู่ที่่คลาสไหน จะได้วางแผนถูก
- ลืมใส่การสืบทอด 
- setNum ควรตรวจสอบก่อนว่ามากกว่า 0 ไหม แล้วลบด้วย ก่อน new ใหม่ num=a ไว้หลังสุด
- เวลาฟังรีเทินอ็อบเจ็ก อ่านดีดีว่า เป็นอ็อบเดิม *this หรืออ็อบใหม่ temp
- static int count อย่าลืม = 0


**********************************************************
*********************************************************
Mid24
18.52-19.13 (21)

1*. B():A(3) { b=3*a; } // a เป็น private
2*. cout<<c.fb4()+c.fc1()<<endl; // pro
3. a.setA(5).setAA(4); // ตัวแรกรีเทิน int ตัวถัดไปใช้อ็อบเจ้ก
4*. cout<<c.getC()+b.fb2(a).fb4()<<endl; // A ไปเรียก fb4 ไม่ได้
5*. int fb3(B b) { b=b.getAA(); } // int = obj

- โดนหลอกกกกก a.setA(5).setAA(4); มันคือฟังก์ชั่น setA(int a) ไม่ใช่ getA()

---------------------------------------------------
16.54-17.30 (36)

- แอททริบิ้วที่เป็นคลาสอยู่อีกคลาสนึง เวลาสร้างแอทตัวนั้นจะเรียกดีฟอลไหม // เรียกด้วยจ้า เรียกตัวเล็กก่อนแล้วมาเรียกตัวหลัก แต่ des ตัวหลักจะตายก่อน แล้วตัวเล็กข้างในค่อยตาย !! ยกเว้นฟังก์ชั่น ไปอ่านข้างล่าง
- cout<<"c2+c1 = "<<c2.plus(c1).get().get().getA()<<endl;
get ตัวแรกจะรีเทิน B ซึ่งมี A a อยู่ข้างใน a ตัวนี้จะถูก copy ด้วย และพอไป get ตัวถัดไป a เล็กจะถูกทำลายทันที แต่ b ตัวหลัก (ตัวที่รีเทิน) ยังคงอยู่

-------------------------------------------------
22.15-23.05 (50)
23.38-23.51 (13)

- des ลืมคืนพื้นที่
- ลืม return ฟังที่เป็น int
- เช็คเงื่อนไข return อย่างเดียว ไม่ใส่ -1/1
- setCorn มีไทป์เป็น string แต่ไปเขียนรับเป็น int
- default ของคลาสลูกไม่เหมือนแม่เสมอไป อย่าลืม B():A(40,4)
- ลืม string.h 

************************************************************
*************************************************************
Mid23

16.36-17.01 (25)

1. 
2*. A g2() { return A(a); } // a?
3*. C p(c.b1); // b1
4*. cout<<b.g1(4)+a.f3()<<endl; // pro
5. cout<<b.g5(c.h3(2))<<endl; // g5 รับ B  แต่ h3 ส่ง C

C p(c.b1); C สืบทอดจาก B แต่ B ไม่ได้เป็นเฟรนของฟังที่เรียกใช้ออันนี้ ได้ไหม // 

- ตัว copy parameter ไม่สามารถไปใช้ฟังชั่นใน protect ได้ ถึงแม้ว่าสถานคลาสจะมีการสืบทอด
int g4(A a) { return a.f1().f3();} ฟัง g4 อยู่ใน B ซึ่ง f1 เป็น pro อยู่นอกคลาสใช้ไม่ได้
- ฟังก์ชั่นโดดๆข้างนอก ต่อให้คลาสไหนประกาศเป็นเฟรนแล้ว ก็ไม่สามารถใช้อ็อบเจ็กเรียกตรงๆได้ เช่น obj1.f1() ไม่ได้ ต้อง f1() ไปเลย

-------------------------------------------------------
17.40-18.09 (29)

B f(int n) {
cout<<"fC"<<endl;
c++;
return B::f(1,n);
}     
สร้างใหม่ป่าวไม่รู้ // ตอนแรกไม่สร้าง ข้างในคือ B& f(1,n) มาเห็นจบฟังชั่น สร้างจ้า
ระวังงงง ตรงรีเทินB::f(1,n) ถึงแม้ข้างในจะคืนค่ากลับมาเป็น & แต่พอส่งมาถึง B::f(1,n) ตรงนี้แล้ว
ไม่มี & จะส่งเป็นแวรูค่ะ นึกถึงเดินผ่าน 2 ประตูติดกัน copy ด้วย

- เวลาไล่เรียก default อย่าลืมดูให้ครบว่าทำอะไรบ้าง ไม่ใช่ไปอัพค่าอย่างเดียว เผื่อมี cout
- num++ มีเฉพาะใน default เวลา copy จะไม่เรียกดีฟอลอยู่แล้ว num เลยไม่ +
- ลืมไล่เรียก des อะไรอ่ะ เรื่องง่ายๆ ทำไมลืม

------------------------------------------------------
22.28-23.09 (41)
23.30-23.50 (20)

************************************************************
************************************************************
Mid29 re2
17.08-17.35 (27)

1. return b[i].g7()==j?b[i]:B(j);
2*. i=c.b[0].f1(a.f3()); // pro
3*. int g1(A a) { return b=a.f1(b); } // ตัวก๊อบใช้ f1
4*. B g3(A a) { b=f1(a.a); return *this; } // a.a
5. j=b.g6(c.h6(0).g4(a)).g7(); // A ใช้ B ไม่ได้

return b[i].g7()==j?b[i]:B(j); คืออะไร ลืม
- A h4(B b, int i, int j) { return b[i].f5(j); รับพาราเป็นอ็อกเจ็กเดี่ยวๆ B b แต่รีเทิน b[i] ไม่ตรงเงื่อนไข ระวัง
- จุดง่ายๆอีกแล้ว คลาสแม่ใช้คลาสลูกไม่ได้

------------------------------------------------
18.57

- ลำดับ cout<<b1.callF2(a).getB()<<endl; ค่าต้นเปลี่ยนไหม // 
- โดนหลอก B(int a):A(a+1) {
cout<<"BB ";
setB(a); show();เซ็ต a +1 แต่ b=a ใส่ 4 ไป b=4 a=5 ไม่ใช่ b,a=5
- เวลา new ไม่ใช่ไปเรียกดีฟอลของทั้งแม่และลูกนะ ต้องดูด้วยว่าใคร new ดีฟอลคลาสนั้นกำหนดไว้ว่าอะไร เช่น B():A(5) ซึ่ง A(int) ไม่มีโชว์

-----------------------------------------------
19.56

แบบนี้ int setNum(int a){
        if(a<=0){
            return -1;
        }
        delete[] pork;
        pork = new Pork[a];
        return 1;
    } ไม่ต้องกำหนดค่าในนี้แล้วสิ เพราะไปเรียก default อัติโน

- type 1-3 1-4 ไปตั้ง if ว่า < 0

---------------------------------------------------------
mid28 final
9.16-9.33 (19)

1*. A f2(A a) { return a.plus(); } // pro
2*. add(b.f1(a)); return *this; // pro
3. i+=x.a+c.b.f6().a; // b ไม่ได้เป็นเฟรน
4*. return c.g4().b.a; // .b
5*. a = c.g5(b.f4(i)->get()); // b ไม่มี get

-------------------------------------------------------
10.27-11.12

- c1.getB(0)->plusTwo().show();; plus return A 







